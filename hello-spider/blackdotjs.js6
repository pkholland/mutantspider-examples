/*
 *  blackdotjs.js6
 *
 *  javascript api into the blackdot library
 *
 */

import * as blackdot_bind from 'blackdot-bind';
import * as ms_loader from 'mutantspider-loader';

// private, "singleton" helper class to load and interface with
// the blackdot library (the thing that is generated by compiling
// blackdot.cpp).
class blackdot {

  // if the blackdot component is not yet fully loaded, then
  // record the call we are trying to make.  Otherwise call
  // into the component
  callComponent(api, args) {
    if (this.blackdot_exports) {
      this.blackdot_exports[api].apply(this, args);
      this.last_call = {api:api, args:args};
    } else
      this.delayed_calls.push({ api, args });
  }

  // if we originally loaded the asmjs version of blackdot
  // and we later are able to load the pexe version, then
  // release the resources for the asmjs one
  freeAsmjsResources(mod_id) {
    if ((this.asmjs_id > -1) && (mod_id > this.asmjs_id)) {
      if (this.modules[this.asmjs_id].type === 'asmjs-web-worker')
        this.modules[this.asmjs_id].module.terminate();
      else if (this.modules[this.asmjs_id].type === 'asmjs-direct')
        window[this.modules[this.asmjs_id].js_module_name] = null;
      delete this.modules[this.asmjs_id];
    }
  }

  constructor() {

    this.highest_loaded_module = -1;
    this.asmjs_id = -1;
    this.json_blackdot_exports = {};
    this.modules = {};
    this.delayed_calls = [];

    // functions that can be called from the asm/pexe/worker to here
    this.callbacks = {

      // called from either blackdot.js and blackdot.pexe when
      // one of those components have finished initializing
      ms_async_startup_complete: (mod_id) => {

        // if we have already loaded a "better" version of
        // blackdot, then ignore this one
        if (mod_id > this.highest_loaded_module) {

          // this is either the first one to load, or is better
          // than what loaded previously

          if (!this.blackdot_exports) {

            // this is the first one to load, need to
            // handle any delayed_calls we may have at this point

            this.blackdot_exports = this.json_blackdot_exports[mod_id];

            this.delayed_calls.forEach(function(v, i, a) {
              this.callComponent(v.api, v.args);
            }, this);
            this.delayed_calls = [];

            this.freeAsmjsResources(mod_id);

          } else {
            // hot swap - it must be that the asmjs version loaded
            // first, and here the pexe version has loaded.  So switch
            // to that one
            this.blackdot_exports = this.json_blackdot_exports[mod_id];
            this.freeAsmjsResources(mod_id);
            if (this.last_call)
              this.callComponent(this.last_call.api, this.last_call.args);
          }
        } else {
          // here it must be that the pexe version loaded first
          // and here the asmjs version has loaded.  But we prefer the
          // pexe version over asmjs, so just ignore this one.
          if (mod_id === this.asmjs_id)
            this.freeAsmjsResources(mod_id+1);
        }

        // no reason to keep around the _function_ that initializes the
        // asmjs records.  This just releases whatever is releasable in that
        // function
        if ((mod_id === this.asmjs_id) && (this.modules[this.asmjs_id].type === 'asmjs-direct'))
          window[this.modules[this.asmjs_id].js_module_name] = null;

      },

      // called when a component fails to load
      ms_async_startup_failed: (mod_id, reason) => {
        if (mod_id > this.highest_loaded_module)
          console.error('startup failed: ' + reason);
        if (mod_id === this.asmjs_id)
          this.freeAsmjsResources(this.asmjs_id+1);
      },

      // called when a component fails during runtime
      ms_error: (reason) => {
        console.error('component error: ' + reason);
      },

      // called when a pexe component fails during runtime
      ms_crash(reason) {
        console.error('component crash: ' + reason);
      },

      bd_show_bitmap(width, height, pixels) {
        if (this.bitmap_listener)
          this.bitmap_listener(width, height, pixels);
      }

    };

    // call the mutantspider module loader to load as many versions
    // of our blackdot component as can be loaded (either 2 of this is
    // Chrome, or 1 if it isn't).  It calls us back with info about
    // each component is will try to load.  This callback occurs prior
    // to calls into (for example) this.callbacks.ms_async_startup_complete
    ms_loader.load_modules(blackdot_bind.submodules, (info) => {

      this.modules[info.mod_id] = { type: info.submodule.type, module: info.module };
      if (info.submodule.type === 'asmjs-direct') {
        info.module.__ms_c_to_js_api__ = this.callbacks;
        this.json_blackdot_exports[info.mod_id] = blackdot_bind.bind(this.callbacks, info.module, this);
        this.asmjs_id = info.mod_id;
        this.modules[info.mod_id].js_module_name = info.submodule.asm_js_module_name;
        window[info.submodule.asm_js_module_name](info.module);
      } else {
        if (info.submodule.type === 'asmjs-web-worker')
          this.asmjs_id = info.mod_id;
        this.json_blackdot_exports[info.mod_id] = blackdot_bind.bind(this.callbacks, info.module, this);
      }

    });

  }

};

var _bd;

export function load_blackdot() {
  if (!_bd)
    _bd = new blackdot();
}

export function set_bitmap_listener(listener) {
  load_blackdot();
  _bd.bitmap_listener = listener;
}

export function gen_blackdot(width, height, dot_x, dot_y) {
  load_blackdot();
  _bd.callComponent('BD_GenBlackDot', [width, height, dot_x, dot_y]);
}

